import{_ as a,c as t,a as n,o as i}from"./app-CtC7YmlN.js";const l={};function r(c,e){return i(),t("div",null,e[0]||(e[0]=[n('<h2 id="读写锁介绍" tabindex="-1"><a class="header-anchor" href="#读写锁介绍"><span>读写锁介绍</span></a></h2><p>现实中的场景：对共享资源有读和写的操作，且写操作没有读操作那么频繁（读多写少）。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源（读读可以并发）；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写操作了（读写，写读，写写互斥）。在读多于写的情况下，读写锁能够提供比排它锁更好的并发和吞吐量。</p><h3 id="三个重要特性" tabindex="-1"><a class="header-anchor" href="#三个重要特性"><span>三个重要特性</span></a></h3><ul><li>公平选择性</li><li>可重入</li><li>锁降级</li></ul><h2 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h2><p>类图</p><p><img src="https://iniconico-image.oss-cn-chengdu.aliyuncs.com/typora/20211218203915.png" alt=""></p><h2 id="读写锁状态的设计" tabindex="-1"><a class="header-anchor" href="#读写锁状态的设计"><span>读写锁状态的设计</span></a></h2><p>如何用一个变量维护多个独立的状态</p><p>按位分割</p><ul><li>读锁：低16位</li><li>写锁：高16位</li></ul>',11)]))}const o=a(l,[["render",r],["__file","AQS-ReentrantReadWriteLock.html.vue"]]),d=JSON.parse('{"path":"/series/back-end/concurrent/AQS-ReentrantReadWriteLock.html","title":"AQS-ReentrantReadWriteLock","lang":"en-US","frontmatter":{"title":"AQS-ReentrantReadWriteLock","date":"2021/12/06","tags":["AQS"],"categories":["back-end"]},"headers":[{"level":2,"title":"读写锁介绍","slug":"读写锁介绍","link":"#读写锁介绍","children":[{"level":3,"title":"三个重要特性","slug":"三个重要特性","link":"#三个重要特性","children":[]}]},{"level":2,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":2,"title":"读写锁状态的设计","slug":"读写锁状态的设计","link":"#读写锁状态的设计","children":[]}],"git":{"createdTime":1736659621000,"updatedTime":1736659621000,"contributors":[{"name":"iniconico","email":"632546065@qq.com","commits":1}]},"filePathRelative":"series/back-end/concurrent/AQS-ReentrantReadWriteLock.md"}');export{o as comp,d as data};
